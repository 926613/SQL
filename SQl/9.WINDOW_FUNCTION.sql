SELECT 
ProductID,
OrderDate,
CustomerID,
SUM(Sales)
FROM Sales.Orders
GROUP BY ProductID,
		ProductID,
		OrderDate,
		CustomerID
-- NO. OF COLUMN IN SELECT STATEMENT MUST BE INCLUDE IN GROUP BY CLAUSE.
-- LIMITATION OF GROUP BY CLAUSE IS : IT CAN'T DO AGGREGATION AND PROVIDE ADDITIONAL INFORMATION AT SAME TIME



--AGGREGATION_FUNCTION  
SELECT 
*,
SUM(Sales) OVER()
FROM Sales.Orders


SELECT 
OrderID,
OrderDate,
ProductID,
OrderStatus,
SUM(Sales) OVER(PARTITION BY PRODUCTID, ORDERSTATUS),
SUM(Sales) OVER(),
SUM(Sales) OVER(PARTITION BY PRODUCTID)
FROM Sales.Orders

SELECT 
OrderID,
ProductID,
Sales,
MAX(Sales) OVER(PARTITION BY PRODUCTID)
FROM Sales.Orders
ORDER BY MAX(Sales) OVER(PARTITION BY PRODUCTID)

SELECT 
OrderID,
OrderDate,
ProductID,
OrderStatus,
Sales,
SUM(Sales) OVER(PARTITION BY ORDERSTATUS ORDER BY ORDERDATE ROWS
					BETWEEN CURRENT ROW AND 2 FOLLOWING	),
SUM(Sales) OVER(PARTITION BY PRODUCTID ORDER BY ORDERDATE ROWS 
					UNBOUNDED PRECEDING)
FROM Sales.Orders


SELECT 
CustomerID,
SUM(Sales) TOTAL_SALES,
RANK() OVER(ORDER BY SUM(Sales)DESC)
FROM Sales.Orders
GROUP BY CustomerID

SELECT 
*,
COUNT(LastName) OVER()
FROM Sales.Customers



SELECT 
CustomerID,
COUNT(1) OVER(PARTITION BY CUSTOMERID)
--COUNT(1)
FROM Sales.Customers
--GROUP BY CustomerID

SELECT 
OrderID,
COUNT(1) OVER(PARTITION BY ORDERID)
FROM Sales.OrdersArchive

SELECT 
OrderID,
OrderDate,
Sales,
ProductID,
SUM(Sales) OVER(),
SUM(Sales) OVER(PARTITION BY PRODUCTID),
ROUND(CAST(Sales AS FLOAT) / SUM(Sales) OVER(), 3) * 100
FROM Sales.Orders


SELECT 
OrderID,
OrderDate,
Sales,
ProductID,
AVG(Sales) OVER(),
AVG(Sales) OVER(PARTITION BY PRODUCTID)
FROM Sales.Orders

SELECT 
CustomerID,
ISNULL(LastName, 'N/A'),
AVG(SCORE) OVER(),
AVG(ISNULL(Score, 0)) OVER()
FROM Sales.Customers

SELECT
OrderID,
OrderDate,
Sales,
AVG_SALES
FROM(
	SELECT 
	OrderID,
	OrderDate,
	Sales,
	AVG(Sales) OVER() AVG_SALES
	FROM Sales.Orders
)T
WHERE Sales > AVG_SALES

SELECT 
OrderID,
OrderDate,
Sales,
ProductID,
MIN(Sales) OVER() MIN_SALES,
MIN(Sales) OVER(PARTITION BY PRODUCTID) MIN_SALES_PRO
FROM Sales.Orders

SELECT
*
FROM(
	SELECT 
	*,
	MAX(Salary) OVER() MAX_SALARY
	FROM Sales.Employees
)T
WHERE Salary = MAX_SALARY

--RUNNING TOTAL
SELECT 
OrderID,
Sales,
SUM(Sales) OVER(ORDER BY ORDERID ROWS UNBOUNDED PRECEDING)
FROM Sales.Orders

-- ROLLING TOTAL
SELECT 
OrderID,
Sales,
SUM(Sales) OVER(ORDER BY ORDERID ROWS 2 PRECEDING)
FROM Sales.Orders
--------------------------------------------------------------
SELECT 
OrderID,
OrderDate,
ProductID,
Sales,
AVG(Sales) OVER(PARTITION BY PRODUCTID ORDER BY ORDERDATE
                ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
FROM Sales.Orders



--INTEGER_BASED_RANKING_FUNCTION 

SELECT 
Sales,
ROW_NUMBER() OVER(ORDER BY SALES DESC),
RANK() OVER(ORDER BY SALES DESC),
DENSE_RANK() OVER(ORDER BY SALES DESC)
FROM Sales.Orders


SELECT
*
FROM(
	SELECT 
	OrderID,
	ProductID,
	Sales,
	ROW_NUMBER() OVER(PARTITION BY PRODUCTID ORDER BY SALES DESC) RANK_BY_PRODUCT
	FROM Sales.Orders
)T
WHERE RANK_BY_PRODUCT = 1


SELECT 
*
FROM(
	SELECT 
	CustomerID,
	SUM(Sales) TOTAL_SALES,
	ROW_NUMBER() OVER(ORDER BY SUM(Sales)) [RANK_CUSTOMRS]
	FROM Sales.Orders
	GROUP BY CustomerID
)T WHERE RANK_CUSTOMRS <= 2

--REMOVE DULPICATE BY USING ROW_NUMBER()
SELECT 
*
FROM(
	SELECT
	ROW_NUMBER() OVER(PARTITION BY ORDERID ORDER BY CREATIONTIME DESC) RN,
	*
	FROM Sales.OrdersArchive
)T
WHERE RN = 1


SELECT 
OrderID,
OrderDate,
Sales,
NTILE(2) OVER(ORDER BY SALES DESC),
NTILE(4) OVER(ORDER BY SALES DESC)
FROM Sales.Orders

---USE CASE: DATA SEGMENT: DIVIDE DATA INTO SMALLER PARTS
SELECT 
*,
CASE BUCKETS
	WHEN 1 THEN 'HIGH'
	WHEN 2 THEN 'MEDIUM'
	ELSE 'LOW'
END
FROM(
	SELECT
	OrderID,
	Sales,
	NTILE(3) OVER(ORDER BY SALES DESC) [BUCKETS]
	FROM Sales.Orders
) T 


SELECT 
*,
NTILE(2) OVER (ORDER BY ORDERID)
FROM Sales.Orders



---PERCENTAGE_BASED_RANKING_FUNCTION
SELECT 
*,
CONCAT(DIST_RANK *100, '%')
FROM(
	SELECT 
	ProductID,
	Price,
	--CUME_DIST() OVER(ORDER BY PRICE DESC) DIST_RANK
	PERCENT_RANK() OVER(ORDER BY PRICE DESC) DIST_RANK
	FROM Sales.Products
) T WHERE DIST_RANK <= 0.4